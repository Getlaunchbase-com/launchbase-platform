# LaunchBase Implementation Spec - Current State

## 1. RunPlan Type (as implemented)

```typescript
// server/ai/orchestration/types.ts

export type Tier = "standard" | "growth" | "premium";
export type RunMode = "tournament" | "production";

export type BuilderGate =
  | {
      enabled: false;
      reason: "tier_not_premium" | "disabled_by_policy" | "incomplete_info";
    }
  | {
      enabled: true;
      allowedSurfaces: Array<"homepage_ui" | "landing_page_ui" | "pricing_ui">;
      maxIterations: number; // e.g. 3-5 builder passes
    };

export type CreditsV1 = {
  included: number;
  remaining: number;
  consumed: number;
};

export type CreativeModeV1 = {
  enabled: boolean;
  capBeforeSelect: number; // 24
};

export type RunPlanV1 = {
  version: "runplan.v1";
  runId: string;
  jobId: string;

  tier: Tier;
  runMode: RunMode;

  // loops for swarm polish (credits will constrain later)
  loopsRequested: number;

  creativeMode: CreativeModeV1;
  builderGate: BuilderGate;

  // prompt packs + policy knobs (deterministic build)
  packs: {
    systems: { packId: string; params: Record<string, unknown> };
    brand: { packId: string; params: Record<string, unknown> };
    critic: { packId: string; params: Record<string, unknown> };
  };

  // budgets (used for guardrails + ops)
  budgets: {
    maxUsd: number;
    maxLatencyMs: number;
  };

  // safety knobs / "truth pack"
  truth: {
    neverInventClaims: true;
    onlyUseIntakeFacts: true;
    requiresApproval: true;
  };

  createdAtIso: string;
};
```

## 2. ShipPacket Type (as implemented)

```typescript
// server/ai/orchestration/types.ts

export type ShipPacketV1 = {
  version: "shippacket.v1";
  intakeId: number;
  runPlanId: number;
  runId: string;
  tier: Tier;

  proposal: {
    systems: unknown | null;
    brand: unknown | null;
    critic: unknown | null;
  };

  preview: {
    url?: string;
    token?: string;
    screenshots: string[];
  };

  execution: {
    buildPlanId: number | null;
    builderSnapshotId: string | null;
  };

  createdAtIso: string;
};
```

## 3. Creative Macro Function (current signature)

```typescript
// scripts/pilot/runPilotMacro.ts

export async function runPilotMacro(params: {
  lane: Lane; // 'web' | 'marketing' | 'app' | 'artwork'
  rep: number;
  runId: string;
  jobId: string;
  plan: any; // Work order (intake data)
  context: any; // Additional context
  stack: PilotStack; // Model configuration
  maxAttempts?: number; // Default: 3
  runMode?: RunMode; // Default: 'tournament'
}): Promise<PilotRun>;

// PilotStack type
type PilotStack = {
  designer_systems_fast: { modelId: string; provider: string; maxTokens: number; temperature: number; timeoutMs?: number };
  designer_brand_fast: { modelId: string; provider: string; maxTokens: number; temperature: number; timeoutMs?: number };
  design_critic_ruthless: { modelId: string; provider: string; maxTokens: number; temperature: number; timeoutMs?: number };
  selector?: { modelId: string; provider: string; maxTokens: number; temperature: number; timeoutMs?: number };
};

// PilotRun return type
export interface PilotRun {
  lane: Lane;
  rep: number;
  runId: string;
  timestamp: string;
  runMode: RunMode;
  status: 'VALID' | 'RETRIED' | 'FAILED';
  systems: {
    changes: any[];
    anchorCount: number;
  };
  brand: {
    changes: any[];
    anchorCount: number;
  };
  critic: {
    issues: any[];
    suggestedFixes: any[];
    pass: boolean;
  };
  finalScore: number;
  truthPenalty: number;
  qualityPenalty: number;
  meta: {
    totalCostUsd: number;
    totalLatencyMs: number;
    attempts: number;
    models: { systems: string; brand: string; critic: string };
    stopReasons: { systems: string; brand: string; critic: string };
    requestIds: { systems: string; brand: string; critic: string };
    normalization: NormalizationTracking;
    usage: UsageTracking;
  };
}
```

## 4. Drizzle Schema (columns added)

```typescript
// drizzle/schema.ts

/**
 * Run plans generated by Field General (AI orchestration plans)
 */
export const runPlans = mysqlTable(
  "run_plans",
  {
    id: int("id").autoincrement().primaryKey(),

    intakeId: int("intakeId").notNull(),
    tenant: varchar("tenant", { length: 32 }).notNull(), // "launchbase" | "vinces"
    customerEmail: varchar("customerEmail", { length: 255 }).notNull(),

    runId: varchar("runId", { length: 128 }).notNull(),
    jobId: varchar("jobId", { length: 128 }).notNull(),

    tier: mysqlEnum("tier", ["standard", "growth", "premium"]).notNull(),
    runMode: mysqlEnum("runMode", ["tournament", "production"]).notNull(),

    creativeModeEnabled: int("creativeModeEnabled").notNull().default(1), // 0/1

    // Full RunPlan JSON (versioned)
    data: json("data").$type<Record<string, unknown>>().notNull(),

    createdAt: timestamp("createdAt").defaultNow().notNull(),
  },
  (t) => ({
    intakeIdx: index("run_plans_intake_idx").on(t.intakeId),
    runIdIdx: index("run_plans_runid_idx").on(t.runId),
  })
);

export type RunPlan = typeof runPlans.$inferSelect;
export type InsertRunPlan = typeof runPlans.$inferInsert;

/**
 * Ship packets (proposals + approvals)
 */
export const shipPackets = mysqlTable(
  "ship_packets",
  {
    id: int("id").autoincrement().primaryKey(),

    intakeId: int("intakeId").notNull(),
    runPlanId: int("runPlanId").notNull(),

    runId: varchar("runId", { length: 128 }).notNull(),

    status: mysqlEnum("status", [
      "DRAFT",
      "READY_FOR_REVIEW",
      "APPROVED",
      "REJECTED",
    ])
      .default("DRAFT")
      .notNull(),

    previewUrl: varchar("previewUrl", { length: 512 }),
    previewToken: varchar("previewToken", { length: 128 }),

    // Full ShipPacket JSON (versioned)
    data: json("data").$type<Record<string, unknown>>().notNull(),

    createdAt: timestamp("createdAt").defaultNow().notNull(),
    updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  },
  (t) => ({
    intakeIdx: index("ship_packets_intake_idx").on(t.intakeId),
    runIdIdx: index("ship_packets_runid_idx").on(t.runId),
    runPlanIdx: index("ship_packets_runplan_idx").on(t.runPlanId),
  })
);

export type ShipPacket = typeof shipPackets.$inferSelect;
export type InsertShipPacket = typeof shipPackets.$inferInsert;
```

## 5. Production Stack Configuration

```json
// config/stacks/stack_creative_production_default.json
{
  "stackId": "creative_production_default",
  "description": "Production stack (2026-01-16): GPT-5.2 systems + 4o-mini brand + Llama 8B selector + Sonnet 4.0 critic",
  "designer_systems_fast": {
    "modelId": "openai/gpt-5-2",
    "provider": "aiml",
    "maxTokens": 4000,
    "temperature": 0.7,
    "timeoutMs": 90000
  },
  "designer_brand_fast": {
    "modelId": "openai/gpt-4o-mini-2024-07-18",
    "provider": "aiml",
    "maxTokens": 4000,
    "temperature": 0.7,
    "timeoutMs": 60000
  },
  "design_critic_ruthless": {
    "modelId": "claude-sonnet-4-20250514",
    "provider": "aiml",
    "maxTokens": 4000,
    "temperature": 0.3,
    "timeoutMs": 90000
  },
  "selector": {
    "modelId": "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo",
    "provider": "aiml",
    "maxTokens": 600,
    "temperature": 0.3,
    "timeoutMs": 45000
  }
}
```

## 6. Current Database Helpers

```typescript
// server/db.ts

// RunPlan helpers
export async function createRunPlan(data: InsertRunPlan): Promise<number> {
  const db = await getDb();
  const result = await db.insert(runPlans).values(data);
  return result[0].insertId;
}

export async function getRunPlansByIntakeId(intakeId: number): Promise<RunPlan[]> {
  const db = await getDb();
  return db.select().from(runPlans).where(eq(runPlans.intakeId, intakeId));
}

export async function getRunPlanByRunId(runId: string): Promise<RunPlan | undefined> {
  const db = await getDb();
  const result = await db.select().from(runPlans).where(eq(runPlans.runId, runId)).limit(1);
  return result[0];
}

// ShipPacket helpers
export async function createShipPacket(data: InsertShipPacket): Promise<number> {
  const db = await getDb();
  const result = await db.insert(shipPackets).values(data);
  return result[0].insertId;
}

export async function getShipPacketsByIntakeId(intakeId: number): Promise<ShipPacket[]> {
  const db = await getDb();
  return db.select().from(shipPackets).where(eq(shipPackets.intakeId, intakeId));
}

export async function getShipPacketByRunId(runId: string): Promise<ShipPacket | undefined> {
  const db = await getDb();
  const result = await db.select().from(shipPackets).where(eq(shipPackets.runId, runId)).limit(1);
  return result[0];
}

export async function updateShipPacketStatus(
  id: number,
  status: "DRAFT" | "READY_FOR_REVIEW" | "APPROVED" | "REJECTED"
): Promise<void> {
  const db = await getDb();
  await db.update(shipPackets).set({ status }).where(eq(shipPackets.id, id));
}
```

## 7. Current Integration Point

```typescript
// server/routers.ts - intakes.submit mutation (lines 114-150)

submit: protectedProcedure
  .input(
    z.object({
      businessName: z.string(),
      industry: z.string(),
      targetAudience: z.string(),
      // ... other fields
    })
  )
  .mutation(async ({ ctx, input }) => {
    const db = await getDb();

    // 1. Create intake record
    const intakeId = await createIntake({
      userId: ctx.user.id,
      tenant: "launchbase",
      // ... map input fields
    });

    // 2. Generate RunPlan via Field General
    const intake = await getIntakeById(intakeId);
    if (!intake) throw new Error("Intake not found");
    
    const runPlan = runFieldGeneral(intake);

    // 3. Store RunPlan in database
    const runPlanId = await createRunPlan({
      intakeId,
      tenant: intake.tenant,
      customerEmail: intake.customerEmail,
      runId: runPlan.runId,
      jobId: runPlan.jobId,
      tier: runPlan.tier,
      runMode: runPlan.runMode,
      creativeModeEnabled: runPlan.creativeMode.enabled ? 1 : 0,
      data: runPlan as any,
    });

    // 4. Create ShipPacket placeholder
    const shipPacketData: ShipPacketV1 = {
      version: "shippacket.v1",
      intakeId,
      runPlanId,
      runId: runPlan.runId,
      tier: runPlan.tier,
      proposal: { systems: null, brand: null, critic: null },
      preview: { screenshots: [] },
      execution: { buildPlanId: null, builderSnapshotId: null },
      createdAtIso: new Date().toISOString(),
    };

    const shipPacketId = await createShipPacket({
      intakeId,
      runPlanId,
      runId: runPlan.runId,
      status: "DRAFT",
      data: shipPacketData as any,
    });

    return { intakeId, runPlanId, shipPacketId };
  }),
```

## 8. What We Need

Please provide drop-in code for:

1. **executeRunPlan.ts** - Function that takes a RunPlan and executes the creative macro
2. **Jobs runner** - DB-backed or in-process job queue for async execution
3. **portal.requestChanges mutation** - Customer-facing API with credits gate
4. **ShipPacket data schema + update function** - Proper typing for proposal/preview/execution fields

## 9. Key Constraints

- **Credits enforcement**: Standard (1 credit), Growth (3 credits), Premium (10 credits)
- **Builder.io gating**: Premium tier only, UI surfaces only (homepage_ui, landing_page_ui, pricing_ui)
- **Email workflow**: Send preview URLs with approval flow (already implemented in server/email.ts)
- **Production stack**: Use config/stacks/stack_creative_production_default.json
- **Validation**: 100% VALID rate achieved in 20-run pilot (no failures allowed)
- **Cost targets**: $0.26/loop (P50), $0.30/loop (P90)
- **Latency targets**: 76s/loop (P50), 95s/loop (P90)
