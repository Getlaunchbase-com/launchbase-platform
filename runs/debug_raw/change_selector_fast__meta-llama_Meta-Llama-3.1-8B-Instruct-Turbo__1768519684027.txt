=== RAW RESPONSE (change_selector_fast) ===
Model: meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo
Request ID: oTT2dRJ-4YNCb4-9be9259c9fd2b74e
Input Tokens: 1296
Output Tokens: 1480
Finish Reason: stop

=== RAW TEXT (6556 chars) ===
## Change Selector

**Select EXACTLY 8 changes** from the provided `candidateChanges` array based on the given selection criteria and hard rules.

### Code Implementation

```javascript
/**
 * ChangeSelector selects the best 8 changes from the provided candidateChanges array.
 * 
 * @param {Object} inputData - The input data containing lane, roleKind, goals, constraints, and candidateChanges.
 * @param {Object} context - The context containing lane, currentDesign, and creativeMode.
 * @returns {Object} A JSON object with exactly 8 selected changes.
 */

function changeSelector(inputData, context) {
  // Get the candidate changes
  const candidateChanges = inputData.candidateChanges;

  // Filter out unbuildable changes
  const validChanges = candidateChanges.filter(change => !change.unbuildable);

  // Remove duplicates based on targetKey
  const uniqueChanges = validChanges.reduce((acc, change) => {
    const existingChange = acc.find(c => c.targetKey === change.targetKey);
    if (existingChange) {
      // If a change with the same targetKey already exists, keep the one with the better rationale
      if (!existingChange.rationale || existingChange.rationale.includes(change.rationale)) {
        return acc;
      } else {
        // Replace the existing change with the better one
        const index = acc.indexOf(existingChange);
        acc.splice(index, 1, change);
        return acc;
      }
    } else {
      // Add the change if it's not a duplicate
      return [...acc, change];
    }
  }, []);

  // Sort the unique changes based on the selection criteria
  uniqueChanges.sort((a, b) => {
    // Buildability
    if (a.unbuildable && !b.unbuildable) {
      return 1;
    } else if (!a.unbuildable && b.unbuildable) {
      return -1;
    }

    // Impact
    const impactA = getImpactScore(a);
    const impactB = getImpactScore(b);
    if (impactA < impactB) {
      return 1;
    } else if (impactA > impactB) {
      return -1;
    }

    // Diversity
    const diversityA = getDiversityScore(a);
    const diversityB = getDiversityScore(b);
    if (diversityA < diversityB) {
      return 1;
    } else if (diversityA > diversityB) {
      return -1;
    }

    // Specificity
    const specificityA = getSpecificityScore(a);
    const specificityB = getSpecificityScore(b);
    if (specificityA < specificityB) {
      return 1;
    } else if (specificityA > specificityB) {
      return -1;
    }

    // Feasibility
    const feasibilityA = getFeasibilityScore(a);
    const feasibilityB = getFeasibilityScore(b);
    if (feasibilityA < feasibilityB) {
      return 1;
    } else if (feasibilityA > feasibilityB) {
      return -1;
    }

    // If all criteria are equal, keep the original order
    return 0;
  });

  // Select the top 8 changes
  const selectedChanges = uniqueChanges.slice(0, 8);

  // Add anchor information
  selectedChanges.forEach(change => {
    const anchor = getAnchor(change, context.currentDesign);
    change.anchor = anchor;
  });

  // Return the selected changes
  return {
    selectedChanges
  };
}

// Helper functions
function getImpactScore(change) {
  // Implement a scoring system to evaluate the impact of each change
  // For example, prioritize changes with clear, measurable improvements
  return change.impactScore || 0;
}

function getDiversityScore(change) {
  // Implement a scoring system to evaluate the diversity of each change
  // For example, prioritize changes that introduce new concepts or ideas
  return change.diversityScore || 0;
}

function getSpecificityScore(change) {
  // Implement a scoring system to evaluate the specificity of each change
  // For example, prioritize changes with concrete anchors (colors, sizes, layouts)
  return change.specificityScore || 0;
}

function getFeasibilityScore(change) {
  // Implement a scoring system to evaluate the feasibility of each change
  // For example, prioritize changes that can be implemented without breaking existing functionality
  return change.feasibilityScore || 0;
}

function getAnchor(change, currentDesign) {
  // Implement a scoring system to retrieve the anchor information for each change
  // For example, retrieve the current value of the anchor for the change
  return currentDesign[change.targetKey];
}

// Call the changeSelector function
const inputData = {
  lane: "web",
  roleKind: "systems",
  goals: [],
  constraints: {},
  candidateChanges: []
};

const context = {
  lane: "web",
  currentDesign: {
    hero: {
      headline: "Launch Your Business",
      cta: "Get Started"
    },
    pricing: {
      tier1: "$49/mo",
      tier2: "$99/mo"
    }
  },
  creativeMode: {
    enabled: true,
    capBeforeSelect: 24
  }
};

const result = changeSelector(inputData, context);
console.log(result);
```

### Assumptions and Limitations

This implementation assumes that the `candidateChanges` array contains objects with the following properties:

* `targetKey`: a unique string representing the target of the change
* `changeType`: a string representing the type of change (e.g., "content", "style", "layout")
* `proposedValue`: a string representing the proposed value for the change
* `rationale`: a string representing the rationale for the change
* `unbuildable`: a boolean indicating whether the change is unbuildable
* `impactScore`: an integer representing the impact score of the change (optional)
* `diversityScore`: an integer representing the diversity score of the change (optional)
* `specificityScore`: an integer representing the specificity score of the change (optional)
* `feasibilityScore`: an integer representing the feasibility score of the change (optional)

The implementation also assumes that the `currentDesign` object contains the current values for the targets of the changes.

The scoring systems for impact, diversity, specificity, and feasibility are implemented as simple integer values, but can be replaced with more complex scoring systems if needed.

The implementation does not handle cases where the input data or context objects are missing or invalid. It is assumed that the input data and context objects are valid and complete.

The implementation does not handle cases where the `candidateChanges` array is empty or contains no valid changes. It is assumed that the `candidateChanges` array contains at least one valid change.

The implementation does not handle cases where the selected changes do not meet the hard rules (no duplicates, no unbuildable changes, etc.). It is assumed that the selected changes meet the hard rules.

=== PARSED JSON ===
NULL (parse failed)